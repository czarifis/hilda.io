\section{Visualization}
\label{section:visualization}



\input{running-example-template}



\subsection{Template Instance}
\label{section:template-instance}



The main challenge when generating visualizations in interactive notebooks is the variance between the APIs of the visualization libraries. For each visualization library the analyst decides to use, she has to perform an installation of the respective packages (which requires advanced technical knowledge on its own), read lengthy documentation pages that dictate how to use functions provided by each library and then engage in tedious imperative programming in order to ``massage" the existing datasets into a set of formats accepted by each employed API function.


\noindent \textbf{\projname\ Visual Units} 

\noindent To shield analysts from this laborious task, \projname\ abstracts out each visual component as a \projname\ \emph{visual unit} (or simply \emph{unit}). In the eyes of an application developer a visual unit is simply a black box that takes as input a JSON value containing the data that describe the visualization and simply constructs the respective visual component. As such a particular instantiation of the unit (denoted as \emph{visual unit instance} or simply \emph{unit instance}) can be described as $\gl{<\% unit } U \gl{ \%> } v \gl{ <\% end unit \%>}$, where $U$ the type of the visual unit and $v$ the JSON value corresponding to the input of the unit. 


==== Edited up to here =====

For instance, \templateinstanceline{highcharts-unit-instance} of Figure \ref{figure:running-example:main-template-instance} show a unit instance of type \texttt{highcharts}. The unit instance specifies both the data that should be shown on the chart (as an array of tuples assigned to the \texttt{data} attribute) and the values of the parameters accepted by the unit (such as the chart's title).


As we will discuss in Section \ref{section:architecture}, visual units are generated by visual unit developers who wrap popular visualization libraries (such as Google Maps, HighCharts, etc) and make them available to application developers through \projname's visual unit library. In addition to the units provided by unit developers, \projname\ also provides a special unit of type \emph{HTML}. In contrast to other units, which expect JSON values, an HTML unit takes as input a sequence of HTML tags, allowing developers to easily create simple HTML content. For ease of exposition we focus in this paper on JSON units. Our results can be easily extended to the HTML unit. \costas{So far we've been talking about JSON++ if we keep that, we should make it clear why in this paragraph we only talk about JSON and HTML}\yannisk{Removed HTML unit encompassing the two JSON units from our running example}


Figure \ref{figure:bnf-template-instance} shows the grammar for template instances. Finally, to simplify the architecture, template instances are internally represented as JSON++ values. This is achieved by encoding a list of unit instances $\gl{<\% unit } U_1 \gl{ \%> } v_1 \gl{ <\% end unit \%>}$ \ldots $\gl{<\% unit } U_n \gl{ \%> } v_n \gl{ <\% end unit \%>}$ as a JSON++ tuple \texttt{\{$U_1'$: $v_1$, \ldots, $U_n'$: $v_n$\}}, where $U_i'$ is a unique identifier assigned by \projname\ to the i-th unit instance. \yannisk{OK or too cryptic?}

\yannis{We need reserved keywords for the attribute names that correspond to units. Eg, \_\_myunit} \costas{How can we have a predifined set of reserved keywords given that there's an arbitrary number of possible units each with a unique name?}

%Based on this idea, \projname\ abstracts out the entire visual page in the form of a logical specification, referred to as a \emph{template instance}. The template instance contains a description of the visual units that should be displayed in the page together with their inputs. For instance, Figure \ref{???} shows the template instance of our running example. It consists of two unit instances, one of type HighCharts and one of type \ref{???}. Each unit instance is denoted as $\gl{<\% unit } U \gl{ \%> } v \gl{ <\% end unit \%>}$, where $U$ the type of the visual unit and $v$ the JSON value corresponding to the input of the unit. A special type of unit is an HTML unit for displaying HTML content. An HTML unit instance is of the form $\gl{<\% html \%> } e_1 \ldots e_n \gl{ <\% end html \%>}$, where $e_1, \ldots, e_n$ are HTML elements.

\subsection{Template}
\label{section:template}

\begin{figure}[t]
\centering
\scriptsize
\begin{tabular}{B}
\hline
 1  & \gn{template}             & \gp   & \gl{<\% template} \gn{template\_name} (\gn{param\_list}) \gl{\%>}                    \\
    &                           &       & ~~ \gn{let}*                                    \\
    &                           &       & ~~ \gn{unit}
\\
    &                           &       & \gl{<\% end template \%>}                                         \\
 2  & \gn{param\_list}			& \gp   & ( \gn{var\_name} (, \gn{var\_name})* )? 
\\ \hline
 3  & \gn{unit}         & \gp   & \gl{<\% unit} \gn{unit\_class} \gl{\%>}               \\
    &                           &       & ~~ \gn{value}                                         \\
    &                           &       & \gl{<\% end unit \%>}                                 \\
 4  & \gn{value}                & \gp   & \gn{jsonpp\_value} %\text{(see Figure~\ref{figure:bnf-value})} 
\\
 5  &                           & \gd   & \gn{unit}                                     
\\
 6  &                           & \gd   & \gn{print}                                                        \\
 7  &                           & \gd   & \gl{[} \gn{for} \gl{]}                                                                                \\
 8  &                           & \gd   & \gl{<} \gn{for} \gl{>}                                                                                \\
 9  &                           & \gd   & \gn{if}                                                                                 \\
  
 10  &                           & \gd   & \gn{bind}                                                         \\
11  &                           & \gd   & \gl{\{} \gn{event}*                                               \\
    &                           &       & ~~ (\gl{\textquotedbl}\gn{string}\gl{\textquotedbl} 
                                             \gl{:} \gn{value}                                              \\
    &                           &       & ~~ (\gl{,} \gl{\textquotedbl}\gn{string}\gl{\textquotedbl} 
                                             \gl{:} \gn{value})* )? \gl{\}}                                           \\ \hline
12  & \gn{let}                 & \gp   & \gl{<\% let} \gn{var\_name} \gl{=} \gn{expr} \gl{\%>}            
\\
13  & \gn{print}                & \gp   & \gl{<\% print} \gn{expr} \gl{\%>}                                 \\
14  & \gn{for}                  & \gp   & \gl{<\% for} \gn{var\_name} \gl{in} \gn{expr} \gl{\%>}           
\\
    &                           &       & ~~ \gn{let}*                                    \\
    &                           &       & ~~ \gn{value}
\\
    &                           &       & \gl{<\% end for \%>}                                              \\
    
14  & \gn{if}                  & \gp   & \gl{<\% if}  \gn{expr} \gl{\%>}           
\\
    &                           &       & ~~ \gn{value}
\\
 &                           &       & ~~ (\gl{<\% elif}  \gn{expr} \gl{\%>} 
 
\\
 &                           &       & ~~ \gn{value})*    
 \\
 &                           &       & ~~ (\gl{<\% else}  \gl{\%>} 
 
\\
 &                           &       & ~~ \gn{value})?    
\\
    &                           &       & \gl{<\% end if \%>}                                              \\
15  & \gn{bind}                 & \gp   & \gl{<\% bind} \gn{var\_name} = \gn{expr} \gl{\%>}                             \\
16  & \gn{event}                & \gp   & \gl{<\% event} \gn{event\_name} \gn{action\_name} \gl{\%>}        \\
17  & \gn{expr}                 & \gp   & \gn{js\_expression}                                               \\
18  &                           & \gd   & \gn{source\_expression}                                                   \\
19  &                           & \gd   & \gn{json\_path}                                                   \\
\hline
\end{tabular}
\caption{BNF Grammar for Templates}
\label{figure:bnf-template}
\end{figure}

\yannis{About Figure \ref{figure:bnf-template}: the syntax allows a single top level unit, which is probably correct but not what the example does.
Is the top level unit always html?}

\yannisk{To do: Modify template BNF grammar to make sure that we can have directives appear inside JSON values}
\emph{Templates} are declarative specifications describing the template instances as a function of UAS data. A template specifies this function through a set of \emph{template directives}, so that it provides syntax similar to well-known template languages, while it is essentially an expression of a functional programming language without recursion. A template also specifies collecting data from the page and catching events \costas{perhaps we mean linking event with corresponding actions?}. 

There are five template directives: \gl{<\% print \%>}, \gl{<\% for \%>}, \gl{<\% let \%>}, \gl{<\% bind \%>}, and \gl{<\% event \%>}. These are used to describe computation, define variables, set up data collection and specify events. We next describe each of them in detail.\\

%Figure \ref{???} shows for instance the template for the heat map view of our running example. As we will explain in Section \ref{section:templates}, the template language is expressive enough to cater for the needs of most visual units and pages encountered in practice, supporting among others iteration through for loops and function calls. An application may contain more then one templates, which can be displayed as the result of actions, discussed next.\\


\yannis{From an expressiveness point of view, let does not add anything. The interesting consideration is whether it has a meaning about IVM: materialized vs virtual intermediate result.}
\noindent {\bf Defining variables.} A template may define variables that are added to the UAS instance so that they can be used in subsequent computation. Variable definition is facilitated by the \gl{let} directive.

The $\gl{<\% let } x \gl{ = } E \gl{ \%>}$ directive defines variable $x$ in the UAS, and assigns to
$x$ the result of evaluating the expression $E$. The expression $E$ can be a JavaScript expression, a source-specific language (such as a SQL query in the case of relational database sources) or a JSON++ path. For example, the template of our running example (\templateline{let}) employs a \gl{let} directive to create a variable \texttt{readings} containing all temperature readings (retrieved from a relational DBMS through a SQL query).\\

{\bf Reporting syntax and semantics.} Computation in a template is specified using the \gl{print} and \gl{for} directives.
The $\gl{<\% for } x \gl{ in } E \gl{ \%> } B \gl{ <\% end for \%>}$ directive specifies that variable $x$ iterates over the result of the expression $E$. In each iteration, the body $B$ of the \gl{for} loop is instantiated. For example, the template of our running example (\templateline{for}) uses a \gl{for} directive to iterate over the sensor readings (stored in the \texttt{readings} variable). For each reading, it generates a new JSON tuple of the form \texttt{\{y:\ldots, color:\ldots\}}, which is the data format expected by the HighCharts unit for each data point. \eat{The values of the \texttt{y} and \texttt{color} attributes are specified through print directives, as explained below.}

% Eaten as per Yannis\' comment

The $\gl{<\% print } E \gl{ \%>}$ directive instantiates the result of expression $E$. For example, the template of the running example uses two \gl{print} directives to generate the values of the \texttt{y} and \texttt{color} attributes of each JSON tuple produced by the \gl{for} directive. \yannis{The part between the ``\{\}" could be removed}\{The value of \texttt{y} is created by printing the value of the \texttt{reading} variable (\templateline{print-y}), while the value of \texttt{color} is generated by calling the \texttt{toCSS} function, which takes as input the current reading and the normal temperature (set through the slider) and produces a CSS color code according to the coloring schema explained above (\templateline{print-color}).\}\\

%(Figure~\ref{figure:running-example:main-template}) generates the CSS color of a \texttt{<td>} element (i.e., of a table cell) by instantiating through a print directive the result of the \texttt{toCss()} function (which translates a value to a CSS color code according to the setting of the threshold).

%The $\gl{<\% refresh } y \gl{ = } E \gl{ \%>}$ directive defines \textit{derived variable} (i.e., a variable that is computed using one or more other variables) $y$ in the UAS, and sets $y$ to the result of expression $E$. The expression $E$ can be a JavaScript expression, a SQL query or a JSON++ path. For example, \yannisk{TBD}
%the heat map template (Figure~\ref{figure:running-example:main-template}) specifies a derived variable \texttt{matrix} for product stock data instantiated to the result of a SQL query.
%\yannisk{Why does the framework differentiate between base and derived variables?}\\ 

%An important distinction between base variables and derived variables is as follows. A view $Y$ is declaratively specified to be refreshed with the evaluation result of $E_Y$, thus enabling the \projname\ framework to utilize IVM optimizations for incrementally evaluating $E_Y$. In contrast, a base variable $X$ is imperatively updated using either \texttt{INSERT} / \texttt{UPDATE} / \texttt{DELETE} commands on the UAS, or user input through the bind directive (explained below), and therefore the \projname\ framework does not optimize these updates.\\

{\bf Collecting data.} In addition to specifying how to compute a template instance, the template's \gl{bind} directive allows the developer to specify how data are collected from user input on the page.

The $\gl{<\% bind } x = E \gl{ \%>}$ directive specifies that the template instance attribute value in whose position the directive appears will be assigned to variable $x$. This allows UAS variables to become bound to input received by visual units.  \yannis{If UAS has not been defined we need to say what is the JavaScript target.} \costas{We should define a Model/VDB variable, that encompasses every client-side variable used in an application. The target in this case would be the Model.x variable} For instance, the template of our running example (\templateline{bind}) uses a \gl{bind} directive to assign to variable \texttt{threshold} the current value of the slider (which is returned by the slider unit as the value of the \texttt{value} variable). The \gl{bind} directive also allows the developer to specify an expression $E$, whose value will be assigned to the variable when the template is first instantiated. For example, the slider of our running example is initialized with the value 65.\\

%In contrast to the \gl{<\% print \%>} directive, which is a one-way binding from the UAS to the visual instance, the \gl{<\% bind \%>} directive specifies a two-way binding between the UAS and the visual instance, thus allowing values to be collected from the visual interface. For instance, \yannisk{TBD}\\
%the heat map template (Figure~\ref{figure:running-example:main-template}) specifies that the value of the slider will be bound (i.e., assigned) to the \texttt{threshold} variable.\\

{\bf Specifying event handlers.} Finally, a template allows also the invocation of actions in response to events. The $\gl{<\% event } e \gl{ } a \gl{ \%>}$ directive specifies that whenever event $e$ of the enclosing unit instance occurs, action $a$ is executed. For instance, \yannisk{Costa, please add event to template and add description here.}\\
%the heat map template (Figure~\ref{figure:running-example:main-template}) specifies that whenever the position of the slider unit is changed, the action \texttt{updateThreshold} will be executed . \yannisk{Costa, what will this action do?} \yannisk{Do we assume that units come with predefined events?}\\

\costas{}

Finally, each template may also accept parameters that are passed to it by its caller by value. When the template is instantiated, \projname\ creates for each parameter an identical-named UAS variable and then sequentially scans the template instantiating its directives.

